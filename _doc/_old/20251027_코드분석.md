# NVR GStreamer 프로젝트 상세 코드 분석

**작성일**: 2025년 10월 27일
**버전**: commit 83add09 - "refactor: 녹화 제어 시스템 안정성 개선"
**총 코드 라인 수**: 약 9,098 라인

---

## 목차

1. [프로젝트 개요](#1-프로젝트-개요)
2. [클래스 다이어그램 및 의존성](#2-클래스-다이어그램-및-의존성)
3. [디렉토리 구조](#3-디렉토리-구조)
4. [프로그램 시작 흐름](#4-프로그램-시작-흐름)
5. [카메라 연결 흐름](#5-카메라-연결-흐름)
6. [비디오 스트리밍 흐름](#6-비디오-스트리밍-흐름)
7. [녹화 시스템 흐름](#7-녹화-시스템-흐름)
8. [재생 시스템 흐름](#8-재생-시스템-흐름)
9. [UI 업데이트 및 시그널-슬롯](#9-ui-업데이트-및-시그널-슬롯)
10. [프로그램 종료 흐름](#10-프로그램-종료-흐름)
11. [핵심 데이터 구조](#11-핵심-데이터-구조)

---

## 1. 프로젝트 개요

### 1.1 프로젝트 정보

**프로젝트명**: Python-based Network Video Recorder (NVR)
**주요 기술**:
- **GStreamer**: 비디오 파이프라인 처리
- **PyQt5**: GUI 프레임워크
- **Python 3.8+**: 메인 언어

### 1.2 핵심 기능

1. **실시간 RTSP 스트리밍**: 네트워크 카메라 영상 실시간 표시
2. **연속 녹화**: 자동 파일 회전 (5/10/30/60분 간격)
3. **재생 기능**: 녹화된 파일 탐색 및 재생
4. **Unified Pipeline**: 단일 파이프라인으로 스트리밍과 녹화 동시 처리 (CPU 사용량 ~50% 절감)

### 1.3 주요 혁신

#### Unified Pipeline Pattern
```
RTSP Source → Decode → Tee ─┬─→ Streaming Branch (Display)
                            │   controlled by: streaming_valve
                            │
                            └─→ Recording Branch (File Storage)
                                controlled by: recording_valve
```

---

## 2. 클래스 다이어그램 및 의존성

### 2.1 전체 아키텍처 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                          Application Layer                       │
│                            (main.py)                             │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             │ creates
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                         UI Layer (PyQt5)                         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                      MainWindow                           │  │
│  │  - 전체 애플리케이션 윈도우                                 │  │
│  │  - 위젯 배치 및 레이아웃 관리                               │  │
│  │  - 시그널-슬롯 연결                                         │  │
│  └───────┬──────────────────┬──────────────────┬──────────────┘  │
│          │                  │                  │                  │
│    ┌─────▼─────┐   ┌───────▼──────┐   ┌──────▼────────┐        │
│    │ GridView  │   │ CameraList   │   │  Recording    │        │
│    │ Widget    │   │ Widget       │   │  Control      │        │
│    └───────────┘   └──────┬───────┘   └───────────────┘        │
│                            │                                      │
│                            │ manages                              │
│                            ↓                                      │
│                   ┌────────────────┐                             │
│                   │ CameraListItem │                             │
│                   │  - UI 요소     │                             │
│                   │  - 연결 버튼   │                             │
│                   └────────┬───────┘                             │
└────────────────────────────┼─────────────────────────────────────┘
                             │ has
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Business Logic Layer                        │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                      CameraStream                          │  │
│  │  - 개별 카메라 스트림 관리                                  │  │
│  │  - 연결/해제 제어                                           │  │
│  │  - 재연결 로직                                              │  │
│  └────────────┬──────────────────────────────────────────────┘  │
│               │ owns                                             │
│               ↓                                                  │
│  ┌────────────────────────────────────────────────────────┐    │
│  │                  UnifiedPipeline                        │    │
│  │  - GStreamer 파이프라인 구성                            │    │
│  │  - Valve 제어 (스트리밍/녹화)                           │    │
│  │  - 버스 메시지 처리                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
                             │ uses
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Infrastructure Layer                        │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────┐            │
│  │ GStreamer  │  │ ConfigMgr   │  │  Services    │            │
│  │  Pipeline  │  │  (Singleton)│  │  - Camera    │            │
│  │  Elements  │  │             │  │  - Storage   │            │
│  └────────────┘  └─────────────┘  └──────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

---

### 2.2 핵심 클래스 관계도

```
                         ┌──────────────┐
                         │  MainWindow  │
                         │  (QMainWindow)│
                         └───────┬──────┘
                                 │
                ┌────────────────┼────────────────┐
                │                │                │
                │                │                │
      ┌─────────▼────────┐  ┌──▼────────┐  ┌───▼──────────┐
      │  GridViewWidget  │  │ Camera    │  │  Recording   │
      │                  │  │ List      │  │  Control     │
      │  - channels[]    │  │ Widget    │  │  Widget      │
      └──────────────────┘  └───┬───────┘  └──────────────┘
                                │
                                │ contains
                                ↓
                      ┌──────────────────┐
                      │ CameraListItem   │
                      │                  │
                      │  - camera_stream ├──────┐
                      │  - camera_config │      │
                      └──────────────────┘      │
                                                │
                                                │ has
                                                ↓
                                    ┌───────────────────┐
                                    │  CameraStream     │
                                    │                   │
                                    │  + connect()      │
                                    │  + disconnect()   │
                                    │  - gst_pipeline   ├──┐
                                    └───────────────────┘  │
                                                           │
                                                           │ owns
                                                           ↓
                                              ┌────────────────────┐
                                              │ UnifiedPipeline    │
                                              │                    │
                                              │ + start()          │
                                              │ + stop()           │
                                              │ + start_recording()│
                                              │ + stop_recording() │
                                              │ - pipeline         │
                                              │ - tee              │
                                              │ - streaming_valve  │
                                              │ - recording_valve  │
                                              └────────────────────┘
```

---

### 2.3 클래스 간 의존성 맵

#### MainWindow 의존성
```
MainWindow
├── depends on (직접 참조)
│   ├── ConfigManager (Singleton)
│   ├── CameraService
│   ├── StorageService
│   ├── GridViewWidget
│   ├── CameraListWidget
│   ├── RecordingControlWidget
│   ├── PlaybackWidget
│   ├── RecordingManager
│   └── PlaybackManager
│
└── indirect dependencies (간접 참조)
    └── CameraStream (via CameraListWidget)
        └── UnifiedPipeline (via CameraStream)
            └── GStreamer Elements
```

#### CameraStream 의존성
```
CameraStream
├── depends on
│   ├── Camera (data model)
│   ├── UnifiedPipeline
│   ├── ConfigManager
│   └── StreamStatus (enum)
│
└── used by
    ├── CameraListWidget
    └── MainWindow (indirectly)
```

#### UnifiedPipeline 의존성
```
UnifiedPipeline
├── depends on
│   ├── GStreamer (Gst, GLib, GstVideo)
│   ├── ConfigManager
│   ├── PipelineMode (enum)
│   └── gstreamer_utils
│
└── used by
    └── CameraStream
```

---

### 2.4 데이터 모델 의존성

```
core/models.py
├── Camera
│   ├── used by:
│   │   ├── CameraStream
│   │   ├── CameraListWidget
│   │   └── ConfigManager
│   └── methods:
│       └── build_rtsp_url_with_auth()
│
├── Recording
│   └── used by:
│       └── PlaybackManager
│
└── StreamStatus
    └── used by:
        └── CameraStream

core/enums.py
├── CameraStatus
├── RecordingStatus
├── PipelineMode
│   └── used by:
│       ├── UnifiedPipeline
│       └── CameraStream
└── PlaybackState
```

---

### 2.5 시그널-슬롯 연결 다이어그램

```
┌─────────────────────┐
│ CameraListWidget    │
│                     │
│ Signals:            │
│  - camera_connected ├───────┐
│  - camera_disconnected      │
│  - camera_selected   ├──┐   │
│  - camera_added          │   │
│  - camera_removed    │   │   │
└─────────────────────┘   │   │
                          │   │
                          │   │ connects to
                          │   │
┌─────────────────────┐   │   │
│ MainWindow          │   │   │
│                     │   │   │
│ Slots:              │   │   │
│  - _on_camera_connected◄───┘
│  - _on_camera_selected◄────┘
│  - _on_camera_disconnected
│  - _on_camera_added
│  - _on_camera_removed
└─────────────────────┘


┌──────────────────────┐
│ RecordingControlWidget│
│                      │
│ Signals:             │
│  - recording_started ├────────┐
│  - recording_stopped │        │
└──────────────────────┘        │
                                │ connects to
                                │
┌─────────────────────┐         │
│ MainWindow          │         │
│                     │         │
│ Slots:              │         │
│  - _on_recording_started◄─────┘
│  - _on_recording_stopped
└─────────────────────┘


┌───────────────────┐
│ UnifiedPipeline   │
│                   │
│ Callback:         │
│  - _recording_    ├──────────┐
│    callback       │          │
└───────────────────┘          │
                               │ calls
                               │
┌──────────────────────────────▼────┐
│ on_recording_state_change         │
│  (registered in MainWindow)       │
│                                   │
│  Updates:                         │
│   - Grid View (channel UI)        │
│   - Recording Control Widget      │
│   - Emits signals                 │
└───────────────────────────────────┘
```

---

### 2.6 모듈 간 import 관계

```
main.py
  └─> ui/main_window.py
        ├─> config/config_manager.py
        ├─> core/services/camera_service.py
        ├─> core/services/storage_service.py
        ├─> ui/grid_view.py
        ├─> ui/camera_list_widget.py
        │     └─> streaming/camera_stream.py
        │           ├─> streaming/gst_pipeline.py
        │           │     ├─> utils/gstreamer_utils.py
        │           │     └─> gi.repository (GStreamer)
        │           └─> core/models.py
        ├─> ui/recording_control_widget.py
        ├─> ui/playback_widget.py
        │     └─> playback/playback_manager.py
        ├─> recording/recording_manager.py
        └─> utils/system_monitor.py
```

---

### 2.7 객체 생명주기 다이어그램

```
[프로그램 시작]
    │
    ├─> ConfigManager (Singleton 생성)
    │     └─> IT_RNVR.json 로드
    │
    ├─> MainWindow 생성
    │     ├─> GridViewWidget 생성
    │     │     └─> VideoChannel[0..n] 생성
    │     │
    │     ├─> CameraListWidget 생성
    │     │     └─> CameraListItem[0..n] 생성
    │     │           └─> CameraStream 생성 (연결 안 됨)
    │     │                 └─> gst_pipeline = None
    │     │
    │     ├─> RecordingControlWidget 생성
    │     ├─> PlaybackWidget 생성
    │     ├─> RecordingManager 생성
    │     └─> PlaybackManager 생성
    │
    └─> MainWindow.show()
          │
          ├─> QTimer(500ms) → _assign_window_handles_to_streams()
          │     └─> stream.window_handle = channel.get_window_handle()
          │
          └─> QTimer(1000ms) → _auto_connect_cameras()
                │
                └─> camera_stream.connect()
                      ├─> UnifiedPipeline 생성
                      │     ├─> Gst.Pipeline 생성
                      │     ├─> GStreamer 요소 생성
                      │     │     ├─> rtspsrc
                      │     │     ├─> rtpdepay
                      │     │     ├─> decoder
                      │     │     ├─> tee
                      │     │     ├─> streaming_valve
                      │     │     ├─> recording_valve
                      │     │     ├─> video_sink
                      │     │     └─> filesink
                      │     └─> 요소 연결
                      │
                      └─> pipeline.set_state(PLAYING)
                            └─> 스트리밍 시작

[사용자: 녹화 시작 버튼 클릭]
    │
    └─> UnifiedPipeline.start_recording()
          ├─> 녹화 파일 생성
          ├─> recording_valve.set_property("drop", False)
          └─> 콜백 호출 → UI 업데이트

[프로그램 종료]
    │
    └─> MainWindow.closeEvent()
          ├─> camera_list._disconnect_all()
          │     └─> camera_stream.disconnect()
          │           └─> gst_pipeline.stop()
          │                 ├─> stop_recording() (녹화 중이면)
          │                 │     └─> 파일 안전하게 저장
          │                 ├─> pipeline.set_state(NULL)
          │                 └─> 스레드 종료
          │
          └─> 애플리케이션 종료
```

---

## 3. 디렉토리 구조

```
nvr_gstreamer/
├── main.py                          # 프로그램 진입점 (200 라인)
│
├── core/                            # 핵심 비즈니스 로직
│   ├── __init__.py
│   ├── models.py                    # 도메인 모델 (Camera, Recording, StreamStatus 등)
│   ├── enums.py                     # 열거형 (CameraStatus, RecordingStatus, PipelineMode)
│   ├── exceptions.py                # 커스텀 예외 클래스
│   └── services/
│       ├── __init__.py
│       ├── camera_service.py        # 카메라 비즈니스 로직, 자동 녹화
│       └── storage_service.py       # 스토리지 관리, 파일 정리
│
├── config/
│   └── config_manager.py            # 설정 관리 (Singleton, 553 라인)
│
├── streaming/
│   ├── gst_pipeline.py              # Unified Pipeline (1,526 라인) ★
│   └── camera_stream.py             # 카메라 스트림 핸들러 (224 라인)
│
├── recording/
│   └── recording_manager.py         # 녹화 관리 (527 라인)
│
├── playback/
│   └── playback_manager.py          # 재생 관리 (672 라인)
│
├── ui/                              # PyQt5 UI 컴포넌트
│   ├── main_window.py               # 메인 윈도우 (882 라인) ★
│   ├── grid_view.py                 # 그리드 뷰 (카메라 표시)
│   ├── camera_list_widget.py        # 카메라 목록 위젯
│   ├── recording_control_widget.py  # 녹화 제어 위젯
│   ├── playback_widget.py           # 재생 위젯
│   ├── video_widget.py              # 비디오 표시 위젯
│   └── camera_dialog.py             # 카메라 추가/편집 대화상자
│
└── utils/
    ├── gstreamer_utils.py           # GStreamer 유틸리티
    └── system_monitor.py            # 시스템 리소스 모니터링
```

---

## 4. 프로그램 시작 흐름

### 4.1 main.py → MainWindow 생성 과정

```
[사용자: python main.py --debug 실행]
    │
    ├─> 1. argparse로 명령줄 인자 파싱
    │     └─> args.debug = True
    │
    ├─> 2. setup_logging(debug=True)
    │     ├─> loguru 설정
    │     └─> DEBUG 레벨 로그 활성화
    │
    ├─> 3. check_dependencies()
    │     └─> GStreamer 설치 확인
    │
    ├─> 4. QApplication 생성
    │     └─> Qt 이벤트 루프 준비
    │
    ├─> 5. ConfigManager.get_instance()
    │     ├─> Singleton 인스턴스 생성 (첫 호출 시)
    │     ├─> IT_RNVR.json 로드
    │     │     ├─> app 설정
    │     │     ├─> cameras 설정
    │     │     ├─> ui 설정
    │     │     ├─> streaming 설정
    │     │     └─> recording 설정
    │     └─> 카메라 설정 파싱
    │           └─> CameraConfigData 객체 생성
    │
    ├─> 6. MainWindow(config_manager) 생성
    │     ├─> __init__() 실행
    │     │     ├─> 6.1 서비스 초기화
    │     │     │     ├─> CameraService 생성
    │     │     │     └─> StorageService 생성
    │     │     │
    │     │     ├─> 6.2 UI 위젯 생성 (_create_widgets)
    │     │     │     ├─> GridViewWidget 생성
    │     │     │     │     └─> VideoChannel[0] 생성 (1x1 그리드)
    │     │     │     │
    │     │     │     ├─> CameraListWidget 생성
    │     │     │     │     ├─> 카메라 설정 순회
    │     │     │     │     └─> CameraListItem 생성
    │     │     │     │           ├─> CameraStream 생성
    │     │     │     │           │     ├─> config 저장
    │     │     │     │           │     ├─> gst_pipeline = None
    │     │     │     │           │     ├─> status = DISCONNECTED
    │     │     │     │           │     └─> RTSP URL 빌드
    │     │     │     │           └─> UI 요소 생성 (버튼, 라벨 등)
    │     │     │     │
    │     │     │     ├─> RecordingControlWidget 생성
    │     │     │     ├─> PlaybackWidget 생성
    │     │     │     ├─> RecordingManager 생성
    │     │     │     └─> PlaybackManager 생성
    │     │     │
    │     │     ├─> 6.3 레이아웃 설정 (_setup_layout)
    │     │     │     ├─> setCentralWidget(GridViewWidget)
    │     │     │     ├─> Camera List Dock (좌측)
    │     │     │     ├─> Recording Control Dock (우측)
    │     │     │     └─> Playback Dock (하단, 숨김)
    │     │     │
    │     │     ├─> 6.4 시그널-슬롯 연결 (_connect_signals)
    │     │     │     ├─> camera_list.camera_connected
    │     │     │     │   → _on_camera_connected
    │     │     │     ├─> camera_list.camera_disconnected
    │     │     │     │   → _on_camera_disconnected
    │     │     │     ├─> recording_control.recording_started
    │     │     │     │   → _on_recording_started
    │     │     │     └─> ... 기타 시그널 연결
    │     │     │
    │     │     ├─> 6.5 초기 데이터 로드
    │     │     │     ├─> _populate_recording_control()
    │     │     │     │     └─> 카메라 목록을 Recording Control에 추가
    │     │     │     └─> _auto_assign_cameras()
    │     │     │           └─> channel[0].update_camera_info("cam_01", "Main Camera")
    │     │     │
    │     │     └─> 6.6 타이머 설정
    │     │           ├─> QTimer.singleShot(500, _assign_window_handles)
    │     │           └─> QTimer.singleShot(1000, _auto_connect_cameras)
    │     │
    │     └─> MainWindow 객체 준비 완료
    │
    ├─> 7. main_window.show()
    │     ├─> Qt가 윈도우 렌더링
    │     ├─> 모든 위젯 화면에 표시
    │     └─> 윈도우 핸들 생성 (OS 레벨)
    │
    ├─> 8. [500ms 후] _assign_window_handles_to_streams()
    │     ├─> channel.get_window_handle() 호출
    │     │     └─> 예: 94502956 (Windows HWND)
    │     └─> stream.window_handle = 94502956
    │
    ├─> 9. [1000ms 후] _auto_connect_cameras()
    │     └─> 자동 연결 (다음 섹션에서 설명)
    │
    └─> 10. app.exec_()
          └─> Qt 이벤트 루프 시작 (프로그램 실행 중)
```

---

## 5. 카메라 연결 흐름

### 5.1 자동 연결 프로세스

```
_auto_connect_cameras()
    │
    ├─> config_manager.get_enabled_cameras()
    │     └─> enabled=True인 카메라만 필터링
    │
    └─> for camera in cameras:
          │
          ├─> streaming_enabled_start == True ?
          │     │
          │     YES
          │     │
          │     ├─> camera_item = camera_list.camera_items[camera_id]
          │     │     └─> CameraListItem 객체
          │     │           └─> camera_stream (CameraStream 객체)
          │     │
          │     ├─> window_handle 찾기
          │     │     └─> channel.camera_id == camera_id인 채널의 핸들
          │     │
          │     ├─> enable_recording = camera.recording_enabled_start
          │     │
          │     └─> camera_stream.connect(window_handle, enable_recording)
          │           │
          │           [CameraStream.connect() 진입]
          │           │
          │           ├─> status = StreamStatus.CONNECTING
          │           │
          │           ├─> mode 결정
          │           │     ├─> enable_recording == True
          │           │     │     → mode = PipelineMode.BOTH
          │           │     └─> enable_recording == False
          │           │           → mode = PipelineMode.STREAMING_ONLY
          │           │
          │           ├─> UnifiedPipeline 생성
          │           │     │
          │           │     [UnifiedPipeline.__init__() 진입]
          │           │     │
          │           │     ├─> rtsp_url 저장
          │           │     ├─> camera_id, camera_name 저장
          │           │     ├─> window_handle 저장
          │           │     ├─> mode 저장
          │           │     ├─> pipeline = None
          │           │     ├─> _is_playing = False
          │           │     ├─> _is_recording = False
          │           │     └─> 녹화 디렉토리 설정
          │           │           └─> Path("recordings")
          │           │
          │           ├─> gst_pipeline.start()
          │           │     │
          │           │     [UnifiedPipeline.start() 진입]
          │           │     │
          │           │     ├─> Gst.init(None)
          │           │     │     └─> GStreamer 초기화
          │           │     │
          │           │     ├─> pipeline = Gst.Pipeline.new("unified_pipeline_cam_01")
          │           │     │
          │           │     ├─> _build_pipeline()
          │           │     │     │
          │           │     │     ├─> [소스 브랜치] GStreamer 요소 생성
          │           │     │     │     ├─> rtspsrc
          │           │     │     │     │     └─> location = "rtsp://admin:1234@192.168.0.131:554/stream"
          │           │     │     │     ├─> rtph264depay
          │           │     │     │     ├─> h264parse
          │           │     │     │     ├─> decoder (avdec_h264 / omxh264dec / v4l2h264dec)
          │           │     │     │     ├─> videoconvert
          │           │     │     │     └─> tee (분기점)
          │           │     │     │
          │           │     │     ├─> [스트리밍 브랜치] 요소 생성
          │           │     │     │     ├─> stream_queue
          │           │     │     │     ├─> streaming_valve (drop=False, 열림)
          │           │     │     │     └─> video_sink (d3dvideosink / xvimagesink)
          │           │     │     │           └─> set_window_handle(94502956)
          │           │     │     │
          │           │     │     ├─> [녹화 브랜치] 요소 생성
          │           │     │     │     ├─> record_queue
          │           │     │     │     ├─> recording_valve
          │           │     │     │     │     ├─> mode == BOTH → drop=False (열림)
          │           │     │     │     │     └─> mode == STREAMING_ONLY → drop=True (닫힘)
          │           │     │     │     ├─> h264parse (재인코딩 없음)
          │           │     │     │     ├─> mp4mux (fragment-duration=1000ms)
          │           │     │     │     └─> filesink
          │           │     │     │           └─> location = "recordings/cam_01/20251027/..."
          │           │     │     │
          │           │     │     ├─> 파이프라인에 요소 추가
          │           │     │     │     └─> pipeline.add(rtspsrc, rtpdepay, ...)
          │           │     │     │
          │           │     │     └─> 요소 연결
          │           │     │           ├─> rtpdepay → h264parse → decoder
          │           │     │           ├─> decoder → videoconvert → tee
          │           │     │           ├─> tee → [스트리밍 브랜치]
          │           │     │           │     └─> stream_queue → streaming_valve → video_sink
          │           │     │           └─> tee → [녹화 브랜치]
          │           │     │                 └─> record_queue → recording_valve → h264parse → mp4mux → filesink
          │           │     │
          │           │     ├─> 버스 메시지 감시 설정
          │           │     │     └─> bus.connect("message", _on_bus_message)
          │           │     │
          │           │     ├─> pipeline.set_state(Gst.State.PLAYING)
          │           │     │     └─> GStreamer 파이프라인 시작
          │           │     │
          │           │     ├─> _is_playing = True
          │           │     │
          │           │     └─> 별도 스레드에서 GLib.MainLoop 실행
          │           │           ├─> _main_loop = GLib.MainLoop()
          │           │           └─> _thread.start()
          │           │                 └─> _run_main_loop()
          │           │
          │           ├─> status = StreamStatus.CONNECTED
          │           │
          │           └─> return True
          │
          └─> camera_list.camera_connected.emit(camera_id)
                │
                [시그널 발행 → 슬롯 실행]
                │
                └─> MainWindow._on_camera_connected(camera_id)
                      │
                      ├─> stream.gst_pipeline.video_sink.set_window_handle()
                      │     └─> 비디오 출력 위치 최종 확인
                      │
                      ├─> channel.set_connected(True)
                      │     └─> UI 업데이트 (초록 테두리)
                      │
                      └─> 녹화 콜백 등록
                            └─> gst_pipeline.register_recording_callback(
                                  on_recording_state_change
                                )
```

---

### 5.2 수동 연결 (사용자가 연결 버튼 클릭)

```
[사용자: 카메라 목록에서 "연결" 버튼 클릭]
    │
    └─> CameraListWidget._on_connect_clicked(camera_id)
          │
          ├─> camera_item = self.camera_items[camera_id]
          │
          ├─> camera_stream.is_connected() ?
          │     │
          │     YES → disconnect() 호출
          │     │
          │     NO  → 연결 시도
          │           │
          │           ├─> window_handle = _get_window_handle_for_camera(camera_id)
          │           │     └─> MainWindow의 grid_view에서 핸들 찾기
          │           │
          │           └─> camera_stream.connect(window_handle)
          │                 └─> [위의 자동 연결과 동일한 과정]
          │
          └─> camera_connected.emit(camera_id)
```

---

## 6. 비디오 스트리밍 흐름

### 6.1 GStreamer 파이프라인 데이터 흐름

```
[RTSP 서버에서 스트림 전송]
    │
    │ (Network packets - RTP/H.264)
    ↓
┌─────────────────────────────────────────────────────────┐
│ rtspsrc                                                  │
│  - RTSP 프로토콜 처리                                     │
│  - RTP 패킷 수신                                         │
│  - location: rtsp://admin:1234@192.168.0.131:554/stream │
│  - protocols: tcp                                        │
│  - latency: 200ms                                        │
└─────────────────┬───────────────────────────────────────┘
                  │ (RTP packets)
                  ↓
┌─────────────────────────────────────────────────────────┐
│ rtph264depay                                            │
│  - RTP depayloading                                     │
│  - H.264 NAL units 추출                                 │
└─────────────────┬───────────────────────────────────────┘
                  │ (H.264 NAL units)
                  ↓
┌─────────────────────────────────────────────────────────┐
│ h264parse                                               │
│  - H.264 스트림 파싱                                     │
│  - 프레임 경계 감지                                      │
└─────────────────┬───────────────────────────────────────┘
                  │ (Parsed H.264 frames)
                  ↓
┌─────────────────────────────────────────────────────────┐
│ Decoder (플랫폼별)                                       │
│  - Windows: avdec_h264 (소프트웨어)                     │
│  - RPi 3: omxh264dec (OpenMAX 하드웨어)                │
│  - RPi 4+: v4l2h264dec (V4L2 하드웨어)                  │
│  - H.264 → Raw Video (YUV420)                           │
└─────────────────┬───────────────────────────────────────┘
                  │ (Raw video frames - YUV420)
                  ↓
┌─────────────────────────────────────────────────────────┐
│ videoconvert                                            │
│  - 색상 공간 변환                                        │
│  - YUV420 → RGB or 플랫폼별 포맷                         │
└─────────────────┬───────────────────────────────────────┘
                  │ (Converted video frames)
                  ↓
┌─────────────────────────────────────────────────────────┐
│ tee (분기점)                                             │
│  - 동일한 데이터를 두 브랜치로 복사                       │
└─────────┬───────────────────┬───────────────────────────┘
          │                   │
          │                   │ (Data duplicated)
          │                   │
          ↓                   ↓
┌─────────────────┐   ┌──────────────────┐
│ 스트리밍 브랜치  │   │ 녹화 브랜치       │
└─────────────────┘   └──────────────────┘


[스트리밍 브랜치]
    │
    ↓
┌─────────────────────────────────────────────┐
│ stream_queue                                │
│  - max-size-buffers: 2                      │
│  - 버퍼링 최소화 (저지연)                    │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────────────┐
│ streaming_valve                             │
│  - drop: False (열림, 데이터 통과)           │
│  - 런타임에 제어 가능                        │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────────────┐
│ video_sink (플랫폼별)                        │
│  - Windows: d3dvideosink                    │
│  - Linux: xvimagesink / waylandsink         │
│  - macOS: glimagesink                       │
│  - window_handle: 94502956                  │
│  - sync: true (A/V 동기화)                  │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
            [화면에 비디오 표시]
            - GridView의 VideoChannel 위젯
            - 실시간 스트리밍 재생


[녹화 브랜치]
    │ (Raw video에서 분기)
    ↓
┌─────────────────────────────────────────────┐
│ record_queue                                │
│  - 버퍼링                                    │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────────────┐
│ recording_valve                             │
│  - drop: True/False (모드에 따라)            │
│  - PipelineMode.STREAMING_ONLY → True (닫힘)│
│  - PipelineMode.BOTH → False (열림)         │
└─────────────────┬───────────────────────────┘
                  │
                  ↓ (valve가 열리면)
┌─────────────────────────────────────────────┐
│ h264parse                                   │
│  - 원본 H.264 스트림 재사용                  │
│  - 재인코딩 없음! (CPU 절약)                 │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────────────┐
│ mp4mux                                      │
│  - MP4 컨테이너로 muxing                     │
│  - fragment-duration: 1000ms                │
│  - Fragment-based MP4 (실시간 쓰기)         │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────────────┐
│ filesink                                    │
│  - location: recordings/cam_01/20251027/... │
│  - sync: false (파일 I/O 비동기)            │
└─────────────────┬───────────────────────────┘
                  │
                  ↓
         [디스크에 MP4 파일 저장]
         recordings/
           └─ cam_01/
              └─ 20251027/
                 └─ cam_01_20251027_140000.mp4
```

---

### 6.2 Valve를 통한 동적 제어

#### Valve 상태 변경 과정

```
[사용자: "녹화 시작" 버튼 클릭]
    │
    └─> RecordingControlWidget._on_record_button_clicked()
          │
          └─> stream.gst_pipeline.start_recording()
                │
                [UnifiedPipeline.start_recording()]
                │
                ├─> 녹화 파일 경로 생성
                │     └─> recordings/cam_01/20251027/cam_01_20251027_143500.mp4
                │
                ├─> filesink.set_property("location", new_file_path)
                │
                ├─> recording_valve.set_property("drop", False)
                │     │
                │     └─> [Valve 열림]
                │           │
                │           [이전: 데이터 차단]
                │           record_queue → recording_valve (drop=True) → 데이터 버림
                │
                │           [이후: 데이터 통과]
                │           record_queue → recording_valve (drop=False) → h264parse
                │                                                            ↓
                │                                                         mp4mux
                │                                                            ↓
                │                                                         filesink
                │                                                            ↓
                │                                                      [파일 쓰기 시작]
                │
                ├─> _is_recording = True
                │
                ├─> _start_rotation_timer()
                │     └─> GLib.timeout_add_seconds(600, _rotate_recording_file)
                │
                └─> _notify_recording_state_change(True)
                      └─> 콜백 호출 → UI 업데이트


[파이프라인 모드 변경]

PipelineMode.STREAMING_ONLY → PipelineMode.BOTH
    │
    ├─> streaming_valve.set_property("drop", False)  # 이미 열림 (유지)
    └─> recording_valve.set_property("drop", False)  # 닫힘 → 열림
          │
          └─> 녹화 시작


PipelineMode.BOTH → PipelineMode.STREAMING_ONLY
    │
    ├─> stop_recording() 호출
    │     ├─> recording_valve.set_property("drop", True)  # 열림 → 닫힘
    │     ├─> filesink.send_event(Gst.Event.new_eos())
    │     │     └─> mp4mux가 파일 finalize
    │     └─> _is_recording = False
    │
    └─> streaming_valve.set_property("drop", False)  # 유지
```

---

## 7. 녹화 시스템 흐름

### 7.1 녹화 파일 생성 과정

```
start_recording() 호출
    │
    ├─> 1. 타임스탬프 생성
    │     └─> timestamp = "20251027_143500"
    │
    ├─> 2. 디렉토리 구조 생성
    │     │
    │     ├─> base_dir = Path("recordings")
    │     ├─> camera_dir = base_dir / "cam_01"
    │     ├─> date_dir = camera_dir / "20251027"
    │     │
    │     └─> date_dir.mkdir(exist_ok=True, parents=True)
    │           └─> recordings/cam_01/20251027/ 생성
    │
    ├─> 3. 파일명 생성
    │     └─> filename = f"cam_01_20251027_143500.mp4"
    │           └─> current_recording_file = "recordings/cam_01/20251027/cam_01_20251027_143500.mp4"
    │
    ├─> 4. Filesink 위치 설정
    │     ├─> filesink = pipeline.get_by_name("filesink")
    │     ├─> filesink.send_event(Gst.Event.new_eos())
    │     │     └─> 이전 파일 마무리 (있다면)
    │     └─> filesink.set_property("location", current_recording_file)
    │
    ├─> 5. Recording Valve 열기
    │     └─> recording_valve.set_property("drop", False)
    │           └─> 데이터 흐름 시작
    │
    ├─> 6. 상태 업데이트
    │     ├─> _is_recording = True
    │     └─> recording_start_time = time.time()
    │
    ├─> 7. 파일 회전 타이머 시작
    │     └─> _rotation_timer_id = GLib.timeout_add_seconds(
    │           rotation_interval,  # 600초 = 10분
    │           _rotate_recording_file
    │         )
    │
    └─> 8. UI 콜백 호출
          └─> _notify_recording_state_change(True)
                │
                └─> on_recording_state_change(camera_id, True)
                      │
                      ├─> Grid View: channel.set_recording(True)
                      │     └─> "● REC" 표시
                      │
                      └─> Recording Control: update_recording_status()
                            └─> 버튼 "녹화 중지"로 변경


[MP4 파일 구조]

recordings/cam_01/20251027/cam_01_20251027_143500.mp4
│
├─> [ftyp] File Type Box
│     └─> 파일 시작 시 작성
│
├─> [moov] Movie Box (초기 메타데이터)
│
├─> [moof] Movie Fragment 1 (1초 데이터)
│     └─> Fragment 헤더
│
├─> [mdat] Media Data 1
│     └─> 실제 H.264 프레임 데이터
│
├─> [moof] Movie Fragment 2
├─> [mdat] Media Data 2
│
├─> ... (계속 쓰기)
│
└─> [녹화 중지 시]
      ├─> EOS 이벤트 전송
      ├─> mp4mux가 남은 프래그먼트 쓰기
      ├─> moov 박스 업데이트
      └─> 파일 닫기
```

---

### 7.2 파일 회전 (Rotation) 과정

```
[10분마다 자동 실행: _rotate_recording_file()]
    │
    ├─> 1. 녹화 중인지 확인
    │     └─> _is_recording == True?
    │           NO → return False (타이머 중지)
    │
    ├─> 2. 새 파일명 생성
    │     ├─> new_timestamp = "20251027_145000"
    │     └─> new_file = "recordings/cam_01/20251027/cam_01_20251027_145000.mp4"
    │
    ├─> 3. 이전 파일 마무리
    │     ├─> filesink = pipeline.get_by_name("filesink")
    │     ├─> filesink.send_event(Gst.Event.new_eos())
    │     │     │
    │     │     └─> [EOS 처리]
    │     │           ├─> mp4mux가 마지막 프래그먼트 쓰기
    │     │           ├─> moov 박스 업데이트
    │     │           └─> 파일 finalize
    │     │                 └─> cam_01_20251027_143500.mp4 (완성)
    │     │
    │     └─> time.sleep(0.2)  # mp4mux 처리 대기
    │
    ├─> 4. 새 파일로 전환
    │     └─> filesink.set_property("location", new_file)
    │           └─> cam_01_20251027_145000.mp4 (새 파일 시작)
    │
    ├─> 5. current_recording_file 업데이트
    │     └─> self.current_recording_file = new_file
    │
    └─> 6. return True (타이머 계속 실행)


[파일 회전 타임라인]

14:35:00  ─┬─> 녹화 시작
           │   cam_01_20251027_143500.mp4 시작
           │
14:45:00  ─┼─> 10분 경과 → 파일 회전
           │   cam_01_20251027_143500.mp4 종료 (10분 분량)
           │   cam_01_20251027_144500.mp4 시작
           │
14:55:00  ─┼─> 10분 경과 → 파일 회전
           │   cam_01_20251027_144500.mp4 종료 (10분 분량)
           │   cam_01_20251027_145500.mp4 시작
           │
15:05:00  ─┴─> 녹화 중지
               cam_01_20251027_145500.mp4 종료 (10분 분량)


[디렉토리 구조]

recordings/
└─ cam_01/
   ├─ 20251026/
   │  ├─ cam_01_20251026_140000.mp4  (600MB, 10분)
   │  ├─ cam_01_20251026_141000.mp4  (600MB, 10분)
   │  └─ ...
   │
   └─ 20251027/
      ├─ cam_01_20251027_140000.mp4  (600MB, 10분)
      ├─ cam_01_20251027_141000.mp4  (600MB, 10분)
      ├─ cam_01_20251027_142000.mp4  (600MB, 10분)
      ├─ cam_01_20251027_143000.mp4  (600MB, 10분)
      ├─ cam_01_20251027_143500.mp4  (600MB, 10분)
      ├─ cam_01_20251027_144500.mp4  (600MB, 10분)
      └─ cam_01_20251027_145500.mp4  (600MB, 10분)
```

---

### 7.3 녹화 중지 과정

```
stop_recording() 호출
    │
    ├─> 1. 상태 확인
    │     └─> _is_recording == True?
    │           NO → return False
    │
    ├─> 2. 상태 업데이트
    │     ├─> _is_recording = False
    │     └─> recording_start_time = None
    │
    ├─> 3. 파일 회전 타이머 정지
    │     └─> GLib.source_remove(self._rotation_timer_id)
    │
    ├─> 4. Recording Valve 닫기
    │     └─> recording_valve.set_property("drop", True)
    │           │
    │           [Valve 닫힘]
    │           record_queue → recording_valve (drop=True) → 데이터 차단
    │                                                          ↓
    │                                                      [새 프레임 안 감]
    │
    ├─> 5. 파일 finalize
    │     ├─> filesink = pipeline.get_by_name("filesink")
    │     ├─> filesink.send_event(Gst.Event.new_eos())
    │     │     │
    │     │     └─> [EOS 처리]
    │     │           ├─> 버퍼에 남은 프레임 모두 쓰기
    │     │           ├─> mp4mux가 moov 박스 작성
    │     │           │     ├─> 파일 메타데이터 (duration, codec info, etc.)
    │     │           │     └─> 인덱스 정보 (seek 가능하도록)
    │     │           └─> filesink가 파일 닫기
    │     │                 └─> OS가 디스크에 flush
    │     │
    │     └─> time.sleep(0.2)  # mp4mux 처리 대기
    │
    ├─> 6. 로그 출력
    │     └─> logger.info(f"Recording stopped: {self.current_recording_file}")
    │
    └─> 7. UI 콜백 호출
          └─> _notify_recording_state_change(False)
                │
                └─> on_recording_state_change(camera_id, False)
                      │
                      ├─> Grid View: channel.set_recording(False)
                      │     └─> "● REC" 표시 제거
                      │
                      └─> Recording Control: update_recording_status()
                            └─> 버튼 "녹화 시작"으로 복원


[녹화 파일 무결성 보장]

✅ 정상 종료 과정:
1. recording_valve.set_property("drop", True)
   → 새 프레임 차단

2. filesink.send_event(Gst.Event.new_eos())
   → mp4mux에 EOS 신호 전송

3. mp4mux 처리:
   ├─> 버퍼의 모든 프레임 처리
   ├─> moov 박스 작성
   │     ├─> mvhd (movie header)
   │     ├─> trak (track info)
   │     └─> stbl (sample table - 인덱스)
   └─> 파일 디스크립터 닫기

4. OS 레벨:
   └─> fsync() → 디스크에 실제 쓰기

결과: 재생 가능한 완전한 MP4 파일

❌ 비정상 종료 (프로그램 크래시, 전원 차단):
   → moov 박스 작성 안 됨
   → 파일 재생 불가 (복구 툴 필요)
```

---

## 8. 재생 시스템 흐름

### 8.1 녹화 파일 스캔

```
PlaybackManager.__init__()
    │
    └─> scan_recordings()
          │
          ├─> recording_base_dir = Path("recordings")
          │
          └─> for camera_dir in recording_base_dir.iterdir():
                │ (예: recordings/cam_01/)
                │
                ├─> camera_id = camera_dir.name  # "cam_01"
                │
                └─> for date_dir in camera_dir.iterdir():
                      │ (예: recordings/cam_01/20251027/)
                      │
                      └─> for file_path in date_dir.glob("*.mp4"):
                            │
                            ├─> RecordingFile 객체 생성
                            │     ├─> camera_id: "cam_01"
                            │     ├─> file_path: Path("recordings/cam_01/20251027/cam_01_20251027_143500.mp4")
                            │     ├─> file_size: 629145600 (600MB)
                            │     └─> timestamp: datetime(2025, 10, 27, 14, 35, 0)
                            │
                            └─> recording_files["cam_01"].append(recording_file)


[결과 데이터 구조]

self.recording_files = {
    "cam_01": [
        RecordingFile(camera_id="cam_01",
                     file_path="recordings/cam_01/20251027/cam_01_20251027_140000.mp4",
                     file_size=629145600,
                     timestamp=datetime(2025, 10, 27, 14, 0, 0)),
        RecordingFile(..., timestamp=datetime(2025, 10, 27, 14, 10, 0)),
        RecordingFile(..., timestamp=datetime(2025, 10, 27, 14, 20, 0)),
        ...
    ],
    "cam_02": [...]
}

└─> 타임스탬프순 정렬됨
```

---

### 8.2 재생 시작

```
[사용자: PlaybackWidget에서 파일 더블클릭]
    │
    └─> PlaybackWidget._on_file_double_clicked(item)
          │
          ├─> file_path = item.data(Qt.UserRole)
          │     └─> "recordings/cam_01/20251027/cam_01_20251027_143500.mp4"
          │
          └─> playback_manager.play_file(file_path, window_handle)
                │
                [PlaybackManager.play_file()]
                │
                ├─> 이전 재생 중지 (있다면)
                │     └─> self.current_playback.stop()
                │
                ├─> PlaybackPipeline 생성
                │     │
                │     [PlaybackPipeline.__init__()]
                │     │
                │     ├─> file_path 저장
                │     ├─> window_handle 저장
                │     ├─> pipeline = None
                │     ├─> _is_playing = False
                │     └─> _playback_rate = 1.0
                │
                └─> playback_pipeline.start()
                      │
                      [PlaybackPipeline.start()]
                      │
                      ├─> 1. 파이프라인 생성
                      │     └─> pipeline = Gst.Pipeline.new("playback_pipeline")
                      │
                      ├─> 2. GStreamer 요소 생성
                      │     │
                      │     ├─> filesrc
                      │     │     └─> location = file_path
                      │     │
                      │     ├─> decodebin (자동 디코더)
                      │     │     └─> MP4 파일 자동 디먹싱 및 디코딩
                      │     │
                      │     ├─> videoconvert
                      │     │
                      │     └─> video_sink
                      │           └─> window_handle 설정
                      │
                      ├─> 3. 파이프라인에 추가
                      │     └─> pipeline.add(filesrc, decodebin, videoconvert, video_sink)
                      │
                      ├─> 4. 요소 연결
                      │     ├─> filesrc → decodebin
                      │     │     └─> decodebin.connect("pad-added", _on_pad_added)
                      │     │           └─> 동적으로 videoconvert 연결
                      │     └─> videoconvert → video_sink
                      │
                      ├─> 5. 버스 메시지 감시
                      │     └─> bus.connect("message", _on_bus_message)
                      │
                      ├─> 6. PLAYING 상태로 전환
                      │     └─> pipeline.set_state(Gst.State.PLAYING)
                      │
                      ├─> 7. 재생 시간 가져오기
                      │     ├─> query_duration()
                      │     │     └─> _duration = 600 (초)
                      │     └─> PlaybackWidget에 전달
                      │           └─> timeline_slider.setMaximum(600)
                      │
                      └─> 8. _is_playing = True


[재생 파이프라인 구조]

┌──────────────┐   ┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│   filesrc    │──>│  decodebin   │──>│ videoconvert │──>│  video_sink  │
│              │   │              │   │              │   │              │
│ location:    │   │ (자동)       │   │              │   │ window_handle│
│ .../file.mp4 │   │ - qtdemux    │   │              │   │              │
│              │   │ - h264parse  │   │              │   │              │
│              │   │ - avdec_h264 │   │              │   │              │
└──────────────┘   └──────────────┘   └──────────────┘   └──────────────┘
```

---

### 8.3 재생 제어

#### 일시정지/재개

```
pause() 호출
    └─> pipeline.set_state(Gst.State.PAUSED)
          ├─> _is_playing = False
          └─> 프레임 표시 멈춤 (마지막 프레임 유지)

resume() 호출
    └─> pipeline.set_state(Gst.State.PLAYING)
          ├─> _is_playing = True
          └─> 재생 재개
```

#### 위치 탐색 (Seek)

```
seek(position_seconds) 호출
    │ (예: 180초 = 3분 위치로 이동)
    │
    ├─> 1. 초 → 나노초 변환
    │     └─> position_ns = 180 * Gst.SECOND
    │                     = 180 * 1,000,000,000
    │                     = 180,000,000,000 ns
    │
    ├─> 2. Seek 이벤트 생성
    │     └─> seek_event = Gst.Event.new_seek(
    │           rate=1.0,                    # 재생 속도
    │           format=Gst.Format.TIME,      # 시간 단위
    │           flags=Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT,
    │           start_type=Gst.SeekType.SET, # 절대 위치
    │           start=position_ns,           # 180초
    │           stop_type=Gst.SeekType.NONE, # 끝까지 재생
    │           stop=0
    │         )
    │
    ├─> 3. 파이프라인에 Seek 이벤트 전송
    │     └─> pipeline.send_event(seek_event)
    │           │
    │           [GStreamer 내부 처리]
    │           │
    │           ├─> FLUSH_START 이벤트 전파
    │           │     └─> 모든 버퍼 비우기
    │           │
    │           ├─> filesrc가 파일에서 180초 위치 찾기
    │           │     └─> MP4 moov 박스의 인덱스 사용
    │           │           └─> 가장 가까운 키프레임 위치
    │           │
    │           ├─> 해당 위치부터 읽기 시작
    │           │
    │           └─> FLUSH_STOP 이벤트 전파
    │                 └─> 새 데이터 흐름 시작
    │
    └─> 4. 재생 위치 업데이트
          └─> _position = 180.0


[PlaybackWidget UI 업데이트]

QTimer(100ms)마다 실행:
    │
    └─> _update_playback_position()
          │
          ├─> position = playback_pipeline.get_position()
          │     └─> query_position(Gst.Format.TIME)
          │           └─> 예: 185초 (3분 5초)
          │
          ├���> timeline_slider.setValue(185)
          │     └─> 슬라이더 이동
          │
          └─> info_label.setText("03:05 / 10:00")
                └─> "현재 위치 / 전체 시간"
```

#### 재생 속도 변경

```
set_playback_rate(rate) 호출
    │ (예: rate=2.0 → 2배속)
    │
    ├─> 1. 현재 위치 가져오기
    │     └─> query_position(Gst.Format.TIME)
    │           └─> current_position = 180초
    │
    ├─> 2. 새 속도로 Seek
    │     └─> seek_event = Gst.Event.new_seek(
    │           rate=2.0,  ← 2배속
    │           format=Gst.Format.TIME,
    │           flags=Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT,
    │           start_type=Gst.SeekType.SET,
    │           start=current_position,  # 현재 위치 유지
    │           stop_type=Gst.SeekType.NONE,
    │           stop=0
    │         )
    │
    ├─> 3. 파이프라인에 전송
    │     └─> pipeline.send_event(seek_event)
    │           └─> 2배속으로 재생 시작
    │
    └─> 4. _playback_rate = 2.0


[속도별 동작]

0.5x (슬로우 모션)
    └─> 프레임 간 간격 2배 증가
        └─> 부드러운 슬로우 모션

1.0x (정상 속도)
    └─> 원본 프레임 레이트 그대로

2.0x (2배속)
    └─> 일부 프레임 스킵
        └─> 키프레임 위주로 디코딩

4.0x (4배속)
    └─> 더 많은 프레임 스킵
        └─> 키프레임만 디코딩
```

---

## 9. UI 업데이트 및 시그널-슬롯

### 9.1 시그널-슬롯 연결 맵

```
┌─────────────────────────────────────────────────────────────────┐
│                       MainWindow.__init__()                      │
│                                                                  │
│  _connect_signals():                                            │
│                                                                  │
│  [카메라 관련]                                                   │
│   camera_list.camera_selected ───────────> _on_camera_selected  │
│   camera_list.camera_connected ──────────> _on_camera_connected │
│   camera_list.camera_disconnected ───────> _on_camera_disconnected│
│   camera_list.camera_added ──────────────> _on_camera_added     │
│   camera_list.camera_removed ────────────> _on_camera_removed   │
│                                                                  │
│  [녹화 관련]                                                     │
│   recording_control.recording_started ──> _on_recording_started │
│   recording_control.recording_stopped ──> _on_recording_stopped │
│                                                                  │
│  [재생 관련]                                                     │
│   playback_widget.playback_started ─────> _on_playback_started  │
│   playback_widget.playback_stopped ─────> _on_playback_stopped  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 9.2 녹화 시작 시 UI 동기화 전체 흐름

```
[사용자: "녹화 시작" 버튼 클릭]
    │
    │ (1) UI 이벤트
    ↓
┌──────────────────────────────────────┐
│ RecordingControlWidget               │
│  _on_record_button_clicked()        │
└────────────┬─────────────────────────┘
             │
             │ (2) 비즈니스 로직 호출
             ↓
┌──────────────────────────────────────┐
│ CameraStream.gst_pipeline            │
│  .start_recording()                  │
└────────────┬─────────────────────────┘
             │
             │ (3) 파이프라인 제어
             ↓
┌──────────────────────────────────────┐
│ UnifiedPipeline.start_recording()    │
│  - recording_valve.set_property()    │
│  - filesink.set_property()           │
│  - _is_recording = True              │
└────────────┬─────────────────────────┘
             │
             │ (4) 콜백 호출
             ↓
┌──────────────────────────────────────┐
│ _notify_recording_state_change(True) │
│  → _recording_callback(cam_id, True) │
└────────────┬─────────────────────────┘
             │
             │ (5) 콜백 함수 실행 (MainWindow에서 등록)
             ↓
┌──────────────────────────────────────┐
│ on_recording_state_change()          │
│  (in MainWindow._on_camera_connected)│
│                                       │
│  ├─> (5a) Grid View 업데이트        │
│  │     for channel in channels:      │
│  │         if channel.camera_id:     │
│  │             channel.set_recording(True)│
│  │               └─> "● REC" 표시 추가    │
│  │                                   │
│  ├─> (5b) Recording Control 업데이트│
│  │     recording_control             │
│  │       .update_recording_status()  │
│  │         └─> 버튼 "녹화 중지"      │
│  │         └─> 상태 "● 녹화 중"      │
│  │         └─> 타이머 시작           │
│  │                                   │
│  └─> (5c) 시그널 발행                │
│        recording_control             │
│          .recording_started          │
│          .emit(camera_id)            │
└────────────┬─────────────────────────┘
             │
             │ (6) 시그널 → 슬롯
             ↓
┌──────────────────────────────────────┐
│ MainWindow._on_recording_started()   │
│  - 추가 UI 업데이트 (선택적)         │
│  - 로그 기록                         │
└──────────────────────────────────────┘


[최종 UI 상태]

Grid View:
┌─────────────────────┐
│ Main Camera         │
│ ● Connected  ● REC │ ← 녹화 표시 추가
│                     │
│  [비디오 재생]      │
└─────────────────────┘

Recording Control Widget:
┌─────────────────────────────┐
│ Main Camera (cam_01)        │
│  [녹화 중지]  ● 녹화 중     │ ← 버튼 및 상태 변경
│  00:05                      │ ← 타이머 표시
└─────────────────────────────┘
```

---

## 10. 프로그램 종료 흐름

### 10.1 종료 순서 (계층적 정리)

```
[사용자: 윈도우 [X] 버튼 클릭 / Alt+F4]
    │
    │ Qt 이벤트
    ↓
┌─────────────────────────────────────────────────────────────┐
│ MainWindow.closeEvent(event)                                │
│                                                              │
│  1. Dock 상태 저장                                           │
│     └─> _save_dock_state()                                  │
│           └─> config_manager.update_ui_dock_state()         │
│                 └─> IT_RNVR.json 업데이트                   │
│                                                              │
│  2. 타이머 정지                                              │
│     ├─> status_timer.stop()                                 │
│     ├─> clock_timer.stop()                                  │
│     └─> cleanup_timer.stop()                                │
│                                                              │
│  3. 시스템 모니터 스레드 정지                                │
│     └─> monitor_thread.stop()                               │
│           └─> _running = False                              │
│                 └─> 스레드 종료                              │
│                                                              │
│  4. 재생 정지                                                │
│     └─> playback_widget.cleanup()                           │
│           └─> playback_manager.stop()                       │
│                 └─> playback_pipeline.stop()                │
│                       └─> pipeline.set_state(NULL)          │
│                                                              │
│  5. 모든 카메라 연결 해제 ★ 가장 중요                        │
│     └─> camera_list._disconnect_all()                       │
│           │                                                  │
└───────────┼──────────────────────────────────────────────────┘
            │
            │ (5-1) 각 카메라 순회
            ↓
┌─────────────────────────────────────────────────────────────┐
│ for camera_item in camera_items.values():                   │
│     if camera_stream.is_connected():                        │
│         camera_stream.disconnect()                          │
└───────────┬─────────────────────────────────────────────────┘
            │
            │ (5-2) 개별 스트림 연결 해제
            ↓
┌─────────────────────────────────────────────────────────────┐
│ CameraStream.disconnect()                                   │
│                                                              │
│  if gst_pipeline:                                           │
│      gst_pipeline.stop()  ← 파이프라인 정지                 │
│      gst_pipeline = None                                    │
│                                                              │
│  status = StreamStatus.DISCONNECTED                         │
└───────────┬─────────────────────────────────────────────────┘
            │
            │ (5-3) 파이프라인 정지
            ↓
┌─────────────────────────────────────────────────────────────┐
│ UnifiedPipeline.stop()                                      │
│                                                              │
│  if pipeline and _is_playing:                               │
│                                                              │
│      1. 타임스탬프 타이머 정지                               │
│         └─> _stop_timestamp_update()                        │
│                                                              │
│      2. 녹화 중이면 안전하게 정지 ★ 핵심                     │
│         if _is_recording:                                   │
│             stop_recording()                                │
│               ├─> _is_recording = False                     │
│               ├─> _stop_rotation_timer()                    │
│               ├─> recording_valve.set_property("drop", True)│
│               │     └─> 데이터 차단                          │
│               ├─> filesink.send_event(Gst.Event.new_eos()) │
│               │     └─> mp4mux가 파일 finalize             │
│               │           ├─> 남은 프레임 쓰기              │
│               │           ├─> moov 박스 작성               │
│               │           └─> 파일 닫기                     │
│               └─> time.sleep(0.2)                           │
│                     └─> 파일 쓰기 완료 대기                 │
│                                                              │
│      3. 파이프라인 NULL 상태로 전환                          │
│         └─> pipeline.set_state(Gst.State.NULL)              │
│               └─> 모든 GStreamer 요소 정리                  │
│                     ├─> rtspsrc 연결 종료                   │
│                     ├─> 디코더 정리                         │
│                     └─> 싱크 정리                           │
│                                                              │
│      4. 메인 루프 종료                                       │
│         └─> _main_loop.quit()                               │
│               └─> GLib 이벤트 루프 종료                     │
│                                                              │
│      5. 스레드 종료 대기                                     │
│         └─> _thread.join(timeout=2.0)                       │
│               └─> 최대 2초 대기                             │
│                                                              │
│      _is_playing = False                                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘


[모든 카메라 정리 완료]
    │
    │ (6) 하위 위젯들의 closeEvent 자동 호출
    ↓
┌──────────────────────────────────────┐
│ RecordingControlWidget.closeEvent()  │
│  - super().closeEvent(event)         │
│  - 특별한 정리 없음 (MainWindow가 처리)│
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ PlaybackWidget.closeEvent()          │
│  - super().closeEvent(event)         │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ GridViewWidget.closeEvent()          │
│  - super().closeEvent(event)         │
└──────────────────────────────────────┘

    │
    │ (7) Qt 정리
    ↓
┌──────────────────────────────────────┐
│ QMainWindow.closeEvent(event)        │
│  - 자식 위젯 모두 정리                │
│  - 메모리 해제                        │
│  - event.accept()                    │
└────────────┬─────────────────────────┘
             │
             │ (8) Qt 이벤트 루프 종료
             ↓
        app.exec_() 종료
             │
             ↓
        sys.exit(0)
             │
             ↓
      [프로그램 종료]
```

---

### 10.2 녹화 파일 안전성 보장

```
[정상 종료 과정]

1. stop_recording() 호출
    │
    ├─> recording_valve.set_property("drop", True)
    │     └─> 새 프레임 차단
    │
    ├─> filesink.send_event(Gst.Event.new_eos())
    │     │
    │     └─> [EOS 이벤트 처리]
    │           │
    │           ├─> 버퍼의 모든 프레임 처리
    │           │     └─> h264parse → mp4mux → filesink
    │           │
    │           ├─> mp4mux가 파일 finalize
    │           │     │
    │           │     ├─> [ftyp] 이미 작성됨 (파일 시작 시)
    │           │     ├─> [mdat] 이미 작성됨 (프래그먼트들)
    │           │     └─> [moov] 작성 ← 가장 중요!
    │           │           ├─> mvhd (movie header)
    │           │           │     └─> duration, timescale 등
    │           │           ├─> trak (track)
    │           │           │     └─> 비디오 트랙 정보
    │           │           └─> stbl (sample table)
    │           │                 └─> 프레임 인덱스 (seek 가능)
    │           │
    │           └─> filesink가 파일 닫기
    │                 └─> fclose() → OS가 디스크에 fsync()
    │
    └─> time.sleep(0.2)
          └─> mp4mux 처리 완료 대기

결과: ✅ 재생 가능한 완전한 MP4 파일


[비정상 종료 (크래시)]

프로그램 갑자기 종료
    │
    └─> stop_recording() 호출 안 됨
          │
          └─> [파일 상태]
                ├─> [ftyp] ✓ 있음
                ├─> [mdat] ✓ 있음 (프래그먼트들)
                └─> [moov] ✗ 없음! ← 문제!
                      │
                      └─> 파일 재생 불가
                            └─> 복구 툴 필요
                                  └─> ffmpeg -i broken.mp4 -c copy fixed.mp4
```

---

## 11. 핵심 데이터 구조

### 11.1 주요 클래스 속성 정리

#### MainWindow
```python
class MainWindow(QMainWindow):
    # 설정 및 서비스
    config_manager: ConfigManager         # 싱글톤 설정 관리자
    camera_service: CameraService         # 카메라 비즈니스 로직
    storage_service: StorageService       # 스토리지 관리

    # UI 위젯
    grid_view: GridViewWidget             # 그리드 뷰 (중앙)
    camera_list: CameraListWidget         # 카메라 목록 (좌측 Dock)
    recording_control: RecordingControlWidget  # 녹화 제어 (우측 Dock)
    playback_widget: PlaybackWidget       # 재생 (하단 Dock)

    # 관리자
    recording_manager: RecordingManager   # 녹화 관리
    playback_manager: PlaybackManager     # 재생 관리

    # 모니터링
    monitor_thread: SystemMonitorThread   # 시스템 리소스 모니터
```

#### CameraStream
```python
class CameraStream:
    # 설정
    config: Camera                        # 카메라 설정 객체
    rtsp_url: str                         # 인증 포함 RTSP URL

    # 파이프라인
    gst_pipeline: Optional[UnifiedPipeline]  # GStreamer 파이프라인
    window_handle: Optional[int]          # 윈도우 핸들 (OS 레벨)

    # 상태
    status: StreamStatus                  # 연결 상태
    _reconnect_count: int                 # 재연결 시도 횟수
    _last_frame_time: float               # 마지막 프레임 시간

    # 통계
    _stats: Dict[str, Any]                # 프레임 수, 연결 시간, 에러
```

#### UnifiedPipeline
```python
class UnifiedPipeline:
    # 기본 정보
    rtsp_url: str
    camera_id: str
    camera_name: str
    window_handle: Optional[int]
    mode: PipelineMode                    # STREAMING_ONLY / RECORDING_ONLY / BOTH

    # GStreamer 파이프라인
    pipeline: Optional[Gst.Pipeline]      # 메인 파이프라인

    # 파이프라인 요소
    tee: Optional[Gst.Element]            # 분기점
    streaming_valve: Optional[Gst.Element]  # 스트리밍 제어
    recording_valve: Optional[Gst.Element]  # 녹화 제어
    video_sink: Optional[Gst.Element]     # 비디오 출력

    # 상태
    _is_playing: bool = False             # 재생 중 여부
    _is_recording: bool = False           # 녹화 중 여부

    # 녹화
    recording_dir: Path                   # recordings/
    current_recording_file: Optional[str] # 현재 녹화 파일 경로
    recording_start_time: Optional[float] # 녹화 시작 시간

    # 스레드
    _main_loop: Optional[GLib.MainLoop]   # GLib 이벤트 루프
    _thread: Optional[threading.Thread]   # 백그라운드 스레드

    # 콜백
    _recording_callback: Optional[Callable]  # 녹화 상태 변경 콜백
```

---

## 결론

이 문서는 NVR GStreamer 프로젝트의 전체 코드 흐름을 상세하게 분석했습니다.

### 핵심 포인트

1. **Unified Pipeline 패턴**: 단일 파이프라인으로 스트리밍과 녹화 동시 처리
2. **Valve 제어**: 런타임에 동적으로 스트리밍/녹화 전환
3. **계층적 정리**: MainWindow가 모든 리소스 정리 총괄
4. **시그널-슬롯**: PyQt5 이벤트 시스템으로 UI-백엔드 동기화
5. **안전한 종료**: 녹화 중 파일 안전하게 저장 (moov 박스 작성)

### 클래스 관계 요약

```
MainWindow (UI 총괄)
    └─> CameraListWidget
          └─> CameraStream (비즈니스 로직)
                └─> UnifiedPipeline (GStreamer 제어)
                      └─> GStreamer Elements (실제 처리)
```

### 개선 가능 영역

1. 에러 복구 메커니즘 강화
2. 다중 카메라 지원 확대 (현재 1x1 그리드)
3. 성능 모니터링 및 최적화
4. 테스트 커버리지 증가
5. 비정상 종료 시 녹화 파일 복구 기능

---

**문서 끝**
