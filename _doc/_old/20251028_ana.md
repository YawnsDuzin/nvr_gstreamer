# NVR GStreamer 시스템 동작 분석

## 1. 프로그램 시작

### 1.1 진입점
- **파일**: `main.py`
- **함수**: `main()`
- **로직**:
  ```python
  # GStreamer 초기화
  Gst.init(None)
  
  # PyQt 애플리케이션 생성
  app = QApplication(sys.argv)
  
  # 메인 윈도우 생성 및 표시
  window = MainWindow()
  window.show()
  ```

### 1.2 메인 윈도우 초기화
- **파일**: `ui/main_window.py`
- **클래스**: `MainWindow.__init__()`
- **로직**:
  ```python
  # 설정 관리자 초기화
  self.config_manager = ConfigManager.get_instance()
  
  # 파이프라인 관리자 생성
  self.pipeline_manager = PipelineManager()
  
  # UI 컴포넌트 생성
  self._setup_ui()
  
  # 카메라 목록 로드
  self._load_cameras()
  ```

## 2. 카메라 스트리밍 시작

### 2.1 UI 트리거
- **파일**: `ui/camera_list_widget.py`
- **함수**: `CameraListWidget._on_connect_clicked()`
- **로직**:
  ```python
  # 선택된 카메라 정보 가져오기
  camera_info = self._get_selected_camera()
  
  # 파이프라인 관리자에 연결 요청
  self.pipeline_manager.connect_camera(camera_info)
  ```

### 2.2 파이프라인 생성
- **파일**: `streaming/pipeline_manager.py`
- **함수**: `PipelineManager.connect_camera()`
- **로직**:
  ```python
  # 통합 파이프라인 생성
  pipeline = UnifiedPipeline(
      rtsp_url=camera_info.rtsp_url,
      camera_id=camera_info.camera_id,
      camera_name=camera_info.camera_name,
      window_handle=video_widget.winId(),
      mode=PipelineMode.STREAMING_ONLY
  )
  
  # 파이프라인 생성 및 시작
  if pipeline.create_pipeline():
      pipeline.start()
  ```

### 2.3 GStreamer 파이프라인 구성
- **파일**: `streaming/gst_pipeline.py`
- **함수**: `UnifiedPipeline.create_pipeline()`
- **로직**:
  ```python
  # RTSP 소스 생성
  rtspsrc = Gst.ElementFactory.make("rtspsrc", "source")
  
  # 디코딩 체인 생성
  depay = Gst.ElementFactory.make("rtph264depay", "depay")
  parse = Gst.ElementFactory.make("h264parse", "parse")
  
  # Tee 엘리먼트 (스트림 분기점)
  tee = Gst.ElementFactory.make("tee", "tee")
  
  # 스트리밍 브랜치 생성
  self._create_streaming_branch()
  
  # 녹화 브랜치 생성 (비활성화 상태)
  self._create_recording_branch()
  ```

### 2.4 스트리밍 브랜치 구성
- **함수**: `UnifiedPipeline._create_streaming_branch()`
- **파이프라인 구조**:
  ```
  tee → stream_queue → streaming_valve → decoder → convert → 
  textoverlay → scale → caps_filter → final_queue → videosink
  ```

### 2.5 파이프라인 시작
- **함수**: `UnifiedPipeline.start()`
- **로직**:
  ```python
  # 상태 전환: NULL → READY → PAUSED → PLAYING
  self.pipeline.set_state(Gst.State.READY)
  self.pipeline.set_state(Gst.State.PAUSED)
  self.pipeline.set_state(Gst.State.PLAYING)
  
  # Valve 설정 적용 (스트리밍만 활성화)
  self._apply_mode_settings()
  ```

## 3. 카메라 녹화 시작

### 3.1 UI 트리거
- **파일**: `ui/recording_control_widget.py`
- **함수**: `RecordingControlWidget._on_start_recording()`
- **로직**:
  ```python
  # 선택된 카메라 ID 가져오기
  camera_id = self._get_selected_camera_id()
  
  # 파이프라인 관리자에 녹화 시작 요청
  self.pipeline_manager.start_recording(camera_id)
  ```

### 3.2 녹화 시작 처리
- **파일**: `streaming/pipeline_manager.py`
- **함수**: `PipelineManager.start_recording()`
- **로직**:
  ```python
  # 해당 카메라의 파이프라인 찾기
  pipeline = self.pipelines.get(camera_id)
  
  # 녹화 시작
  if pipeline:
      pipeline.start_recording()
  ```

### 3.3 녹화 브랜치 활성화
- **파일**: `streaming/gst_pipeline.py`
- **함수**: `UnifiedPipeline.start_recording()`
- **로직**:
  ```python
  # 녹화 파일명 생성
  timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
  self.current_recording_file = f"{camera_id}_{timestamp}.{file_format}"
  
  # 녹화 브랜치 재생성 (타임스탬프 초기화)
  self._recreate_recording_sink()
  
  # 파일 회전 타이머 시작
  self._start_rotation_timer()
  ```

### 3.4 녹화 브랜치 재생성
- **함수**: `UnifiedPipeline._recreate_recording_sink()`
- **로직**:
  ```python
  # 1. Valve 닫기 (데이터 흐름 차단)
  self.recording_valve.set_property("drop", True)
  
  # 2. 기존 엘리먼트 제거
  self.pipeline.remove(record_parse)
  self.pipeline.remove(muxer)
  self.pipeline.remove(file_sink)
  
  # 3. 새 엘리먼트 생성 (타임스탬프 초기화)
  record_parse = Gst.ElementFactory.make("h264parse", "record_parse")
  muxer = Gst.ElementFactory.make("matroskamux", "muxer")
  file_sink = Gst.ElementFactory.make("filesink", "filesink")
  
  # 4. 연결 및 상태 전환
  recording_valve → record_parse → muxer → file_sink
  
  # 5. Valve 열기 (녹화 시작)
  self.recording_valve.set_property("drop", False)
  ```

## 4. 카메라 녹화 중지

### 4.1 UI 트리거
- **파일**: `ui/recording_control_widget.py`
- **함수**: `RecordingControlWidget._on_stop_recording()`
- **로직**:
  ```python
  # 선택된 카메라 ID 가져오기
  camera_id = self._get_selected_camera_id()
  
  # 파이프라인 관리자에 녹화 중지 요청
  self.pipeline_manager.stop_recording(camera_id)
  ```

### 4.2 녹화 중지 처리
- **파일**: `streaming/gst_pipeline.py`
- **함수**: `UnifiedPipeline.stop_recording()`
- **로직**:
  ```python
  # 파일 회전 타이머 중지
  self._stop_rotation_timer()
  
  # Valve 닫기 (녹화 중지)
  self.recording_valve.set_property("drop", True)
  
  # EOS 이벤트로 파일 완료
  eos_event = Gst.Event.new_eos()
  self.muxer.send_event(eos_event)
  
  # 상태 업데이트
  self._is_recording = False
  ```

## 5. 카메라 스트리밍 중지

### 5.1 UI 트리거
- **파일**: `ui/camera_list_widget.py`
- **함수**: `CameraListWidget._on_disconnect_clicked()`
- **로직**:
  ```python
  # 선택된 카메라 정보 가져오기
  camera_info = self._get_selected_camera()
  
  # 파이프라인 관리자에 연결 해제 요청
  self.pipeline_manager.disconnect_camera(camera_info.camera_id)
  ```

### 5.2 파이프라인 정지
- **파일**: `streaming/pipeline_manager.py`
- **함수**: `PipelineManager.disconnect_camera()`
- **로직**:
  ```python
  # 해당 카메라의 파이프라인 찾기
  pipeline = self.pipelines.get(camera_id)
  
  # 파이프라인 정지 및 제거
  if pipeline:
      pipeline.stop()
      del self.pipelines[camera_id]
  ```

### 5.3 파이프라인 종료
- **파일**: `streaming/gst_pipeline.py`
- **함수**: `UnifiedPipeline.stop()`
- **로직**:
  ```python
  # 타임스탬프 업데이트 타이머 정지
  self._stop_timestamp_update()
  
  # 녹화 중이면 먼저 정지
  if self._is_recording:
      self.stop_recording()
  
  # 파이프라인 상태를 NULL로 전환
  self.pipeline.set_state(Gst.State.NULL)
  
  # 메인 루프 종료
  self._main_loop.quit()
  ```

## 핵심 아키텍처

### Valve 기반 제어
- **스트리밍 Valve**: `streaming_valve.drop = False/True`
- **녹화 Valve**: `recording_valve.drop = False/True`
- **독립적 제어**: 각 브랜치를 독립적으로 활성화/비활성화

### 파이프라인 구조
```
RTSP Source → Depay → Parse → Tee ─┬─→ Streaming Branch (Display)
                                   └─→ Recording Branch (File Storage)
```

### 상태 관리
- **파이프라인 상태**: NULL → READY → PAUSED → PLAYING
- **녹화 상태**: `_is_recording` 플래그로 관리
- **UI 동기화**: 콜백을 통한 상태 변경 알림